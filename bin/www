#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('faf-backend:server');
var http = require('http');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

// --- SOCKET.IO SETUP ---
const io = require('socket.io')(server, {
  cors: {
    origin: "*", // Allow all for dev
    methods: ["GET", "POST"]
  }
});

const jwt = require('jsonwebtoken');
const chatService = require('../src/modules/chat/chat.service');

// Make io accessible to controllers
app.set('io', io);

io.use(async (socket, next) => {
  try {
    const token = socket.handshake.auth.token;
    if (!token) return next(new Error('Authentication error'));
    
    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'secret');
    socket.user = decoded; // { id, email, role }
    next();
  } catch (err) {
    next(new Error('Authentication error'));
  }
});

io.on('connection', (socket) => {
  console.log(`User connected: ${socket.user.id}`);

  // Join a personal room for direct messages? 
  // Or join conversation rooms.
  // Let's join a personal room to receive notifications/invites
  socket.join(`user_${socket.user.id}`);

  socket.on('join_conversation', (conversationId) => {
    socket.join(`conversation_${conversationId}`);
    console.log(`User ${socket.user.id} joined conversation ${conversationId}`);
  });

  socket.on('send_message', async (data) => {
    // data: { conversationId, content }
    try {
      const { conversationId, content } = data;
      const senderId = socket.user.id;

      // Save to DB
      const message = await chatService.saveMessage(conversationId, senderId, content);

      // Emit to room
      io.to(`conversation_${conversationId}`).emit('receive_message', message);
      
      // Send Notification to other participants
      const notificationService = require('../src/modules/notifications/notification.service');
      const participants = await chatService.getParticipants(conversationId);
      
      for (const p of participants) {
          if (p.user_id !== senderId) {
               await notificationService.createNotification({
                    userId: p.user_id,
                    type: 'NEW_MESSAGE',
                    title: 'New Message',
                    message: `You have a new message`, // Could include sender name if we fetched it
                    data: { conversationId, messageId: message.id },
                    io
               });
          }
      }
      
    } catch (e) {
      console.error("Send message error:", e);
      socket.emit('error', { message: "Failed to send message" });
    }
  });

  socket.on('disconnect', () => {
    console.log('User disconnected');
  });
});

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
  console.log('dang chay', port)
}
